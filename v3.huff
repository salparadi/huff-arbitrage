// +-------------------------------------------+
// |                Interfaces                 |
// +-------------------------------------------+

// Withdraw WETH withdrawWETH202(uint256)
#define function withdrawWETH202(uint256) nonpayable returns ()

// Withdraw ETH withdrawETH508()
#define function withdrawETH508() nonpayable returns ()

// Deposit WETH depositWETH1059()
#define function depositWETH1059() payable returns ()

// Deposit ETH depositETH422()
#define function depositETH422() payable returns ()

// Uniswap V3 Swap Callback
#define function uniswapV3SwapCallback(int256,int256,bytes) payable returns ()

// +-------------------------------------------+
// |                Constants                  |
// +-------------------------------------------+

#define constant MAX_SQRT_RATIO = 0xFFFD8963EFD1FC6A506488495D951D5263988D25

#define constant MIN_SQRT_RATIO = 0x1000276A4

#define constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2

#define constant OWNER = // DEPLOYER/OWNER ADDRESS HERE

// +-------------------------------------------+
// |              Function Sigs                |
// +-------------------------------------------+

// transfer(address to, uint value)
#define constant TRANSFER_SIG = 0xa9059cbb00000000000000000000000000000000000000000000000000000000

// transferFrom(address from, address to, uint value)
#define constant TRANSFER_FROM_SIG = 0x23b872dd00000000000000000000000000000000000000000000000000000000

// swap(uint amount0Out, uint amount1Out, address to, bytes data)
#define constant V2_SWAP_SIG = 0x022c0d9f00000000000000000000000000000000000000000000000000000000

// swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes data)
#define constant V3_SWAP_SIG = 0x128acb0800000000000000000000000000000000000000000000000000000000

// deposit()
#define constant WETH_DEPOSIT_SIG = 0xd0e30db000000000000000000000000000000000000000000000000000000000

// +---------------------------------------+
// |     TWO POOL SWAP ENCODING FORMAT     |
// +---------------------------------------+

// *-----------*---------------------------*
// | Bytes     |  Value                    |
// *-----------+---------------------------*
// | 1         |  Pool Flag                |
// | 4         |  Amount In                |
// | 4         |  Amount Out               |
// | 20        |  Pool A                   |
// | 1         |  Pool A Out Pos           |
// | 20        |  Pool B                   |
// | 1         |  Pool B Out Pos           |
// | 14        |  Pool A Out Amount        |
// *-----------*---------------------------*

// +---------------------------------------+
// |    THREE POOL SWAP ENCODING FORMAT    |
// +---------------------------------------+

// *-----------*---------------------------*
// | Bytes     |  Value                    |
// *-----------+---------------------------*
// | 1         |  Pool Flag                |
// | 4         |  Amount In                |
// | 4         |  Amount Out               |
// | 20        |  Pool A                   |
// | 1         |  Pool A Out Pos           |
// | 20        |  Pool B                   |
// | 1         |  Pool B Out Pos           |
// | 20        |  Pool C                   |
// | 1         |  Pool C Out Pos           |
// | 14        |  Pool A Out Amount        |
// | 14        |  Pool B Out Amount        |
// *-----------*---------------------------*


#define macro CONSTRUCTOR() = takes (0) returns (0) {
 
    push0
    callvalue
    gt

    deposit jumpi

    deposit:
        [WETH_DEPOSIT_SIG]                              // [WETH_DEPOSIT_SIG, ]
        push0 mstore                                    // []

        // Set up the CALL parameters
        push0                                           // [out_size]
        push0                                           // [out_offset, out_size]
        push0                                       	// [in_size, out_offset, out_size]
        push0                                           // [in_offset, in_size, out_offset, out_size]
        callvalue                                       // [value, in_offset, in_size, out_offset, out_size]
        
        [WETH]                                          // [WETH, value, in_offset, in_size, out_offset, out_size, calldata, v3_amount_out, v3_amount_in]
        gas
        call

}


#define macro MAIN() = takes (0) returns (0) {
	// evm.codes caller = be862ad9abfe6f22bcb087716c7d89a26051f74c
	// evm.codes address = 9bbfed6889322e016e0a02ee459d306fc19545d8

	calldatasize				// [calldatasize]
	check_caller jumpi			// [check_caller jumpi, calldatasize]

	stop
	stop

	check_caller:
		[OWNER]					// [OWNER, 0x06, calldatasize]
		caller
		eq						// [(msg.sender == OWNER), 0x06, calldatasize]
		v3_swap_jump jumpi		// [v3_swap jumpi, (msg.sender == OWNER), 0x06, calldatasize]

		[OWNER]					// [OWNER, 0x06, calldatasize]
		origin					// [originAddr, OWNER, 0x06, calldatasize]
		eq						// [(originAddr == OWNER), 0x06, calldatasize]
		v3_callback_jump jumpi	// [v3_callback_jump jumpi, (originAddr == OWNER), 0x06, calldatasize]
		
		fallback jump

	v3_swap_jump:
		push0					// [0x00]
		calldataload			// [data[0x00]]			
		push0					// [0x00, data[0x00]]								
		byte					// [byte[0x00]]
		jump					// []  
	
	v3_callback_jump:
		0x84					// [0x84]
		calldataload			// [data[0x00]]			
		push0					// [0x00, data[0x00]]								
		byte					// [byte[0x00]]
		jump					// [] 

	// withdraw_weth 				4b
	withdraw_weth:
		withdraw_weth_jump jump
	
	// withdraw_eth 				50
	withdraw_eth:
		withdraw_eth_jump jump
	
	// deposit_weth 				55
	deposit_weth:
		deposit_weth_jump jump
	
	// deposit_eth 					5a
	deposit_eth:
		deposit_eth_jump jump
	//
	// #1 V2 > V3 					5f
	v2_v3:
		v2_v3_jump jump

	//
	// #1 V2 > V3 callback 			64
	v2_v3_callback:
		v2_v3_callback_jump jump

	//
	// #2 V3 > V2					69
	v3_v2:
		v3_v2_jump jump

	//
	// #2 V3 > V2 callback			6e
	v3_v2_callback:
		v3_v2_callback_jump jump

	//
	// #3 V3 > V3 					73
	v3_v3:
		v3_v3_jump jump
	
	//
	// #3 V3 > V3 callback 1		78
	v3_v3_callback_1:
		v3_v3_callback_1_jump jump

	//
	// #3 V3 > V3 callback 2		7c
	v3_v3_callback_2:
		v3_v3_callback_2_jump jump
	//
	// #5 V2 > V2 > V3				82
    v2_v2_v3:
		v2_v2_v3_jump jump
	//
	// #5 V2 > V2 > V3 callback		87
	v2_v2_v3_callback:
		v2_v2_v3_callback_jump jump
	//
	// #6 V2 > V3 > V2				8c
	v2_v3_v2:
		v2_v3_v2_jump jump
	//
	// #6 V2 > V3 > V2 callback		91
	v2_v3_v2_callback:
		v2_v3_v2_callback_jump jump
	//
	// #7 V2 > V3 > V3				96
	v2_v3_v3:
		v2_v3_v3_jump jump
	//
	// #7 V2 > V3 > V3 callback 1	9b
	v2_v3_v3_callback_1:
		v2_v3_v3_callback_1_jump jump
	//
	// #7 V2 > V3 > V3 callback 2	a0
	v2_v3_v3_callback_2:
		v2_v3_v3_callback_2_jump jump
	//
	// #8 V3 > V3 > V3				a5
	v3_v3_v3:
		v3_v3_v3_jump jump
	//
	// #8 V3 > V3 > V3 callback 1	aa
	v3_v3_v3_callback_1:
		v3_v3_v3_callback_1_jump jump
	//
	// #8 V3 > V3 > V3 callback 2	af
	v3_v3_v3_callback_2:
		v3_v3_v3_callback_2_jump jump
	//
	// #8 V3 > V3 > V3 callback 3	b4
	v3_v3_v3_callback_3:
		v3_v3_v3_callback_3_jump jump
	//
	// #9 V3 > V3 > V2				b9
	v3_v3_v2:
		v3_v3_v2_jump jump
	//
	// #9 V3 > V3 > V2 callback 1	be
	v3_v3_v2_callback_1:
		v3_v3_v2_callback_1_jump jump
	//
	// #9 V3 > V3 > V2 callback 2	c3
	v3_v3_v2_callback_2:
		v3_v3_v2_callback_2_jump jump
	//
	// #10 V3 > V2 > V3				c8
	v3_v2_v3:
		v3_v2_v3_jump jump
	//
	// #10 V3 > V2 > V3 callback 1	cd
	v3_v2_v3_callback_1:
		v3_v2_v3_callback_1_jump jump
	//
	// #10 V3 > V2 > V3 callback 2	d2
	v3_v2_v3_callback_2:
		v3_v2_v3_callback_2_jump jump
	//
	// #11 V3 > V2 > V2				d7
	v3_v2_v2:
		v3_v2_v2_jump jump
	//
	// #11 V3 > V2 > V2 callback 1	dc
	v3_v2_v2_callback_1:
		v3_v2_v2_callback_1_jump jump
	//
	// Bailout
	fallback jump

	// #1 V2 > V3
	// V3 Pool 2 Swap to contract, trigger callback
	v2_v3_jump:

		//=========================
		// V3 Swap: Pool 2 > Contract
		//=========================
		STORE_V3_SWAP_SIG()
		STORE_CONTRACT()				// To: contract

		LOAD_POOL_B_OUT_POS()			// V3 Out
		iszero v2_v3_one_for_zero_jump jumpi

		STORE_ZERO_FOR_ONE()
		STORE_TWO_POOL_A_OUT_AMOUNT()	// Copy from calldata to memory
		STORE_MIN_SQRT()
		STORE_OFFSET()
		0x64							// Callback flag
		STORE_DATA_30()					// Store actual data
		LOAD_POOL_B()					// Pool to swap on
		V3_SWAP()
		stop

		v2_v3_one_for_zero_jump:
			STORE_ONE_FOR_ZERO()
			STORE_TWO_POOL_A_OUT_AMOUNT()	// Copy from calldata to memory
			STORE_MAX_SQRT()
			STORE_OFFSET()
			0x64							// Callback flag
			STORE_DATA_30()					// Store actual data
			LOAD_POOL_B()					// Pool to swap on
			V3_SWAP()
			stop
	
	//
	// #1 V2 > V3 Callback
	// Transfer to Pool 1, V2 Pool 1 swap to Pool 2
	v2_v3_callback_jump:

		//=========================
		// Profit Check
		//=========================
		CALLBACK_LOAD_ACTUAL_AMOUNT_OUT()			// [actual_amount_out+2, actual_v3_amount_in]
		CALLBACK_LOAD_DESIRED_AMOUNT_OUT()			// [desired_amount_out, actual_amount_out+2, actual_v3_amount_in]	
		lt											// [lt?, actual_v3_amount_in]
	
		v2_v3_callback_continue jumpi
		push0 push0 revert
		v2_v3_callback_continue:					// [actual_v3_amount_in]

			//=========================
			// Transfer: Contract > Pool 1
			//=========================
			CALLBACK_LOAD_POOL_A()					// [pool_1, actual_v3_amount_in]
			CALLBACK_LOAD_DESIRED_AMOUNT_IN()		// [amount_in, pool_1, actual_v3_amount_in]
			dup2									// [pool_1_copy, amount_in, pool_1, actual_v3_amount_in]
			address									// [self, pool_1_copy, amount_in, pool_1, actual_v3_amount_in]

			// Stack needs to be from, to, amount
			TRANSFER_FROM()							// [pool_1, actual_v3_amount_in]

			//=========================
			// V2 Swap: Pool 1 > Pool 2
			//=========================
			caller									// [pool_2, pool_1, actual_v3_amount_in]
			dup3									// [actual_v3_amount_in_copy, pool_2, pool_1, actual_v3_amount_in]
			push0									// [0, actual_v3_amount_in_copy, pool_2, pool_1, actual_v3_amount_in]

			// Determine output slot for V2 swap
			CALLBACK_LOAD_POOL_A_OUT_POS()
			iszero v2_v3_out_zero_jump jumpi

			v2_v3_callback_finish jump
				
			v2_v3_out_zero_jump:
				swap1								// [actual_v3_amount_in_copy, 0, pool_2, pool_1, actual_v3_amount_in]
			
			// Stack neeeds to be amount0, amount1, recipient, pool
			v2_v3_callback_finish:
				V2_SWAP()							// [result]
				stop

	//
	// #2 V3 > V2
	// V3 Pool 1 Swap to Pool 2, trigger callback
	v3_v2_jump:

		//=========================
		// V3 Swap: Pool 1 > Pool 2
		//=========================
		STORE_V3_SWAP_SIG()
		STORE_POOL_A()					// To: V2 Pool 2

		LOAD_POOL_B_OUT_POS()			// V3 Pool 1 Out
		iszero v3_v2_one_for_zero jumpi

		STORE_ZERO_FOR_ONE()
		STORE_AMOUNT_IN()
		STORE_MIN_SQRT()
		STORE_OFFSET()
		0x6e							// Callback Flag
		STORE_DATA_30()
		LOAD_POOL_B()					// Call Swap on V3 Pool 1
		V3_SWAP()
		stop

		v3_v2_one_for_zero:
			STORE_ONE_FOR_ZERO()
			STORE_AMOUNT_IN()
			STORE_MAX_SQRT()
			STORE_OFFSET()
			0x6e						// Callback Flag
			STORE_DATA_30()
			LOAD_POOL_B()				// Call Swap on V3 Pool 1
			V3_SWAP()
			stop

	//
	// #2 V3 > V2 Callback
	// V2 Pool 2 swap to contract, transfer to Pool 1
	v3_v2_callback_jump:

		//=========================
		// V2 Swap: Pool 2 > Contract
		//=========================
		CALLBACK_LOAD_POOL_A()						// [pool_2]
		address										// [address, pool_2]
		CALLBACK_LOAD_DESIRED_AMOUNT_OUT()			// [amount_out, address, pool_2]
		push0										// [0, amount_out, address, pool_2]

		CALLBACK_LOAD_POOL_A_OUT_POS()
		iszero v3_v2_out_zero_jump jumpi
								
		v3_v2_callback_continue jump

		v3_v2_out_zero_jump:
			swap1									// [amount_out, 0, address, pool_2]

		v3_v2_callback_continue:
			// Stack neeeds to be amount0, amount1, recipient, from (V2 pool_2)
			V2_SWAP()								// [result, 0, amount_out]


		//=========================
		// Transfer: Contract > Pool
		//=========================
		CALLBACK_LOAD_DESIRED_AMOUNT_IN()			// [amount_in, self]
		caller										// [caller, amount_in]
		address										// [self, caller, amount_in]

		// Stack needs to be from, to, amount
		TRANSFER_FROM()								// [1, 0, calldata]
		stop
	
	//
	// #3 V3 > V3
	// V3 Pool 2 swap to contract, trigger callback
	v3_v3_jump:

		//=========================
		// V3 Swap: Pool 2 > Contract
		//=========================
		STORE_V3_SWAP_SIG()
		STORE_CONTRACT() // to
		LOAD_POOL_B_OUT_POS()

		iszero v3_v3_one_for_zero jumpi

		STORE_ZERO_FOR_ONE()
		STORE_TWO_POOL_A_OUT_AMOUNT() // amount into pool 2
		STORE_MIN_SQRT()
		STORE_OFFSET()
		0x78
		STORE_DATA_30()
		LOAD_POOL_B()
		V3_SWAP()
		stop

		v3_v3_one_for_zero:
			STORE_ONE_FOR_ZERO()
			STORE_TWO_POOL_A_OUT_AMOUNT()
			STORE_MAX_SQRT()
			STORE_OFFSET()
			0x78
			STORE_DATA_30()
			LOAD_POOL_B()
			V3_SWAP()
			stop
	
	//
	// #3 V3 > V3 Callback 1
	// V3 Pool 1 swap to Pool 2, trigger callback
	v3_v3_callback_1_jump:

		//=========================
		// Profit Check
		//=========================
		CALLBACK_LOAD_ACTUAL_AMOUNT_OUT()			// [actual_amount_out+2, actual_amount_in]
		CALLBACK_LOAD_DESIRED_AMOUNT_OUT()			// [desired_amount_out, actual_amount_out+2, actual_amount_in]	
		lt											// [lt?, actual_amount_in]

		v3_v3_callback_1_continue jumpi
		push0 push0 revert		
		v3_v3_callback_1_continue:				// [flag]

			//=========================
			// V3 Swap: Pool 1 > Pool 2
			//=========================
			STORE_V3_SWAP_SIG()
			STORE_CALLER() // to (V3 Pool 2)

			CALLBACK_LOAD_POOL_A_OUT_POS()

			iszero v3_v3_callback_1_one_for_zero jumpi

			STORE_ZERO_FOR_ONE()
			CALLBACK_STORE_AMOUNT_IN()
			STORE_MIN_SQRT()
			STORE_OFFSET()
			0x7d								// Callback Flag
			CALLBACK_STORE_DATA_5()
			CALLBACK_LOAD_POOL_A()				// Pool to swap on
			V3_SWAP()
			stop

			v3_v3_callback_1_one_for_zero:
				STORE_ONE_FOR_ZERO()
				CALLBACK_STORE_AMOUNT_IN()
				STORE_MAX_SQRT()
				STORE_OFFSET()
				0x7d							// Callback Flag
				CALLBACK_STORE_DATA_5()
				CALLBACK_LOAD_POOL_A()			// Pool to swap on
				V3_SWAP()
				stop

	//
	// #3 V3 > V3 Callback 2
	// Transfer to Pool 1
	v3_v3_callback_2_jump:

		//=========================
		// Transfer: Contract > Pool
		//=========================
		CALLBACK_LOAD_DESIRED_AMOUNT_IN()			// [amount_in, flag]
		caller // to								// [caller, amount_in, flag]
		address // from								// [self, caller, amount_in, flag]

		// Stack needs to be from, to, amount
		TRANSFER_FROM()								// [1, 0, flag, calldata]
		stop
	//
	// #5 V2 > V2 > V3:
	// V3 Pool 3 Swap to contract, trigger callback
	v2_v2_v3_jump:

		//=========================
		// V3 Swap: Pool 3 > Contract
		//=========================
		STORE_V3_SWAP_SIG()
		STORE_CONTRACT()

		LOAD_POOL_C_OUT_POS()
		iszero v2_v2_v3_one_for_zero_jump jumpi

		STORE_ZERO_FOR_ONE()
		STORE_THREE_POOL_B_OUT_AMOUNT()
		STORE_MIN_SQRT()
		STORE_OFFSET()
		0x87
		STORE_DATA_86()
		LOAD_POOL_C()
		V3_SWAP()
		stop

		v2_v2_v3_one_for_zero_jump:
			STORE_ONE_FOR_ZERO()
			STORE_THREE_POOL_B_OUT_AMOUNT()
			STORE_MAX_SQRT()
			STORE_OFFSET()
			0x87
			STORE_DATA_86()
			LOAD_POOL_C()
			V3_SWAP()
			stop

	//
	// #5 V2 > V2 > V3 Callback
	// Transfer to Pool 1, V2 Pool 1 swap to Pool 2, V2 Pool 2 swap to Pool 3
	v2_v2_v3_callback_jump:

		//=========================
		// Check profit
		//=========================
		CALLBACK_LOAD_ACTUAL_AMOUNT_OUT()			// [pool_3_amount_out+2, pool_3_amount_in]
		CALLBACK_LOAD_DESIRED_AMOUNT_OUT()			// [desired_amount_out, pool_3_amount_out+2, pool_3_amount_in]	
		lt											// [lt?, pool_3_amount_in]

		v2_v2_v3_callback_continue_1 jumpi
		push0 push0 revert		
		
		v2_v2_v3_callback_continue_1:				// [pool_3_amount_in]

			//=========================
			// Transfer: Contract > Pool 1
			//=========================
			CALLBACK_LOAD_DESIRED_AMOUNT_IN()		// [amount_in, pool_1, pool_3_amount_in]
			CALLBACK_LOAD_POOL_A()					// [pool_1, pool_3_amount_in]
			address									// [self, amount_in, pool_1, pool_3_amount_in]

			// Stack needs to be from, to, amount
			TRANSFER_FROM()							// [status, pool_1, pool_3_amount_in]

			//=========================
			// V2 Swap: Pool 1 > Pool 2
			//=========================
			CALLBACK_LOAD_POOL_A()					// [pool_1, pool_3_amount_in]
			CALLBACK_LOAD_POOL_B()					// [pool_2, pool_1, pool_3_amount_in]
			CALLBACK_LOAD_POOL_A_OUT_AMOUNT()		// [pool_1_out_amount, pool_2, pool_1, pool_3_amount_in]
			push0									// [0, pool_1_out_amount, pool_2, pool_1, pool_3_amount_in]

			// If pool 1 out pos is 0, swap amounts
			CALLBACK_LOAD_POOL_A_OUT_POS()
			iszero v2_v2_v3_callback_pool_a_zero_jump jumpi

			v2_v2_v3_callback_continue_2 jump		
				
			v2_v2_v3_callback_pool_a_zero_jump:
				swap1								// [pool_1_out_amount, 0, pool_2_copy, pool_1, pool_2, pool_3_amount_in]
			
			// Stack needs to be amount0, amount1, pool_2, pool_1
			v2_v2_v3_callback_continue_2:
				// Stack: pool_1_out, 0, to, from
				V2_SWAP()							// [result, pool_1, pool_2, pool_3_amount_in]

			//=========================
			// V2 Swap: Pool 2 > Pool 3
			//=========================
			CALLBACK_LOAD_POOL_B()					// [pool_2, pool_1, pool_3_amount_in]
			caller									// [pool_3, pool_2, pool_1, pool_3_amount_in]
			dup4									// [pool_3_amount_in_copy, pool_3, pool_2, pool_1, pool_3_amount_in]
			//CALLBACK_LOAD_POOL_B_OUT_AMOUNT()		// [pool_2_out, pool_3, pool_2, pool_1, pool_3_amount_in]
			push0									// [0, pool_2_out, pool_3, pool_2, pool_1, pool_3_amount_in]
			
			// If pool 2 out pos is 0, swap amounts
			CALLBACK_LOAD_POOL_B_OUT_POS()			
			iszero v2_v2_v3_callback_pool_b_zero_jump jumpi
			
			v2_v2_v3_callback_continue_3 jump

			v2_v2_v3_callback_pool_b_zero_jump:
				swap1								// [pool_2_out, 0, pool_3, pool_2, pool_1, actual_v3_amount_in]

			// Stack needs to be amount0, amount1, pool_3, pool_2
			v2_v2_v3_callback_continue_3:
				// Stack: pool_2_out, 0, to, from
				V2_SWAP()							// [result, pool_1, actual_v3_amount_in]
				stop
				
	//
	// #6 V2 > V3 > V2
	// V3 Pool 2 swap to Pool 3, trigger callback
	v2_v3_v2_jump:
		
		//=========================
		// V3 Swap: Pool 2 > Pool 3
		//=========================
		STORE_V3_SWAP_SIG()
		STORE_POOL_C()						// To

		LOAD_POOL_B_OUT_POS()
		iszero v2_v3_v2_one_for_zero_jump jumpi

		STORE_ZERO_FOR_ONE()
		STORE_THREE_POOL_A_OUT_AMOUNT()		// Amount out of Pool 1 into Pool 2
		STORE_MIN_SQRT()
		STORE_OFFSET()
		0x91
		STORE_DATA_86()
		LOAD_POOL_B()
		V3_SWAP()
		stop

		v2_v3_v2_one_for_zero_jump:
			STORE_ONE_FOR_ZERO()
			STORE_THREE_POOL_A_OUT_AMOUNT()	// Amount out of Pool 1 into Pool 2
			STORE_MAX_SQRT()
			STORE_OFFSET()
			0x91							// Callback flag
			STORE_DATA_86()				// Store passthrough calldata
			LOAD_POOL_B()					// From
			V3_SWAP()
			stop

	//
	// #6 V2 > V3 > V2 Callback
	// V2 Pool 3 Swap to Contract, Transfer to Pool 1, V2 Pool 1 swap to Pool 2
	v2_v3_v2_callback_jump:

		//=========================
		// V2 Swap: Pool 3 > Contract
		//=========================
		CALLBACK_LOAD_POOL_C()					// [pool_3]
		address									// [self, pool_3]
		CALLBACK_LOAD_DESIRED_AMOUNT_OUT()		// [desired_amount_out, self, pool_3]
		push0									// [0, desired_amount_out, self, pool_3]

		// If pool 3 out pos is 0, swap amounts
		CALLBACK_LOAD_POOL_C_OUT_POS()
		iszero v2_v3_v2_callback_pool_c_zero_jump jumpi

		v2_v3_v2_callback_continue_1 jump		
			
		v2_v3_v2_callback_pool_c_zero_jump:
			swap1								// [desired_amount_out, 0, self, pool_3]
		
		// Stack needs to be amount0, amount1, to, from
		v2_v3_v2_callback_continue_1:
			V2_SWAP()							// [result]
		
		//=========================
		// Transfer: Contract > Pool 1
		//=========================
		CALLBACK_LOAD_DESIRED_AMOUNT_IN()		// [desired_amount_in]
		CALLBACK_LOAD_POOL_A()					// [pool_1, desired_amount_in]
		address									// [self, pool_1, desired_amount_in]

		// Stack needs to be from, to, amount
		TRANSFER_FROM()							// [status, pool_1, actual_v3_amount_in]

		//=========================
		// V2 Swap: Pool 1 > Pool 2
		//=========================
		CALLBACK_LOAD_POOL_A()					// [pool_1]
		caller									// [pool_2, pool_1]
		CALLBACK_LOAD_POOL_A_OUT_AMOUNT()		// [pool_1_out, pool_2, pool_1]
		push0									// [0, pool_1_out, pool_2, pool_1]

		// If pool 1 out pos is 0, swap amounts
		CALLBACK_LOAD_POOL_A_OUT_POS()
		iszero v2_v3_v2_callback_pool_a_zero_jump jumpi

		v2_v3_v2_callback_continue_2 jump		
			
		v2_v3_v2_callback_pool_a_zero_jump:
			swap1								// [pool_1_out, 0, pool_2, pool_1]
		
		// Stack needs to be amount0, amount1, to, from
		v2_v3_v2_callback_continue_2:
			V2_SWAP()							// [result]
			stop

	
	
	
	//
	// #7 V2 > V3 > V3
	// V3 Pool 3 swap to contract, trigger callback
	v2_v3_v3_jump:

		//=========================
		// V3 Swap: Pool 3 > Contract
		//=========================
		STORE_V3_SWAP_SIG()
		STORE_CONTRACT()					// To: V2

		LOAD_POOL_C_OUT_POS()
		iszero v2_v3_v3_one_for_zero jumpi

		STORE_ZERO_FOR_ONE()
		STORE_THREE_POOL_B_OUT_AMOUNT()
		STORE_MIN_SQRT()
		STORE_OFFSET()
		0x9b
		STORE_DATA_86()
		LOAD_POOL_C()					// Call Swap on this pool
		V3_SWAP()
		stop

		v2_v3_v3_one_for_zero:
			STORE_ONE_FOR_ZERO()
			STORE_THREE_POOL_B_OUT_AMOUNT()
			STORE_MAX_SQRT()
			STORE_OFFSET()
			0x9b
			STORE_DATA_86()
			LOAD_POOL_C()					// Call Swap on this pool
			V3_SWAP()
			stop
	//
	// #7 V2 > V3 > V2 Callback 1
	// V3 Pool 2 swap to Pool 3 trigger callback
	v2_v3_v3_callback_1_jump:

		//=========================
		// Check profit
		//=========================
		CALLBACK_LOAD_ACTUAL_AMOUNT_OUT()			// [actual_V3_amount_out+2, actual_V3_amount_in]
		CALLBACK_LOAD_DESIRED_AMOUNT_OUT()			// [desired_amount_out, actual_V3_amount_out+2, actual_V3_amount_in]	
		lt											// [lt?, actual_V3_amount_in]

		v2_v3_v3_callback_continue_1 jumpi
		push0 push0 revert		
		
		v2_v3_v3_callback_continue_1:				// [actual_V3_amount_in]

			//=========================
			// V3 Swap: Pool 2 > Pool 3
			//=========================
			STORE_V3_SWAP_SIG()
			STORE_CALLER() 						// to (V3 Pool 3)

			CALLBACK_LOAD_POOL_B_OUT_POS()

			iszero v2_v3_v3_callback_1_one_for_zero jumpi

			// if 00>01:
			STORE_ZERO_FOR_ONE()
			CALLBACK_STORE_THREE_POOL_A_OUT_AMOUNT()
			STORE_MIN_SQRT()
			STORE_OFFSET()
			0xa0								// Callback Flag
			CALLBACK_STORE_DATA_86()
			CALLBACK_LOAD_POOL_B()				// Pool to swap on
			V3_SWAP()
			stop

			v2_v3_v3_callback_1_one_for_zero:
				STORE_ONE_FOR_ZERO()
				CALLBACK_STORE_THREE_POOL_A_OUT_AMOUNT()
				STORE_MAX_SQRT()
				STORE_OFFSET()
				0xa0							// Callback Flag
				CALLBACK_STORE_DATA_86()
				CALLBACK_LOAD_POOL_B()			// Pool to swap on
				V3_SWAP()
				stop
	// 
	// #7 V2 > V3 > V2 Callback 2
	// Transfer to Pool 1, V2 Pool 1 swap to Pool 2, 
	v2_v3_v3_callback_2_jump:
		
		//=========================
		// Transfer: Contract > Pool 1
		//=========================
		CALLBACK_LOAD_POOL_A()					// [pool_1]
		CALLBACK_LOAD_DESIRED_AMOUNT_IN()		// [amount_in, pool_1]
		dup2									// [pool_1_copy, amount_in, pool_1]
		//CALLBACK_LOAD_POOL_A()					// [pool_1, amount_in]
		address									// [self, pool_1_copy, amount_in, pool_1]

		// Stack needs to be from, to, amount
		TRANSFER_FROM()							// [status]

		//=========================
		// V2 Swap: Pool 1 > Pool 2
		//=========================
		//CALLBACK_LOAD_POOL_A()					// [pool_1]
		caller									// [pool_2, pool_1]
		CALLBACK_LOAD_POOL_A_OUT_AMOUNT()		// [pool_1_out, pool_2, pool_1]
		push0									// [0, pool_1_out, pool_2, pool_1]

		// If pool 1 out pos is 0, swap amounts
		CALLBACK_LOAD_POOL_A_OUT_POS()
		iszero v2_v3_v3_callback_pool_a_zero_jump jumpi

		v2_v3_v3_callback_continue_2 jump		
			
		v2_v3_v3_callback_pool_a_zero_jump:
			swap1								// [pool_1_out, 0, pool_2, pool_1]
		
		// Stack needs to be amount0, amount1, to, from
		v2_v3_v3_callback_continue_2:
			V2_SWAP()							// [result]
			stop
	//
	// #8 V3 > V3 > V3
	// V3 Pool 3 swap to contract, trigger callback
	v3_v3_v3_jump:
		
		//=========================
		// V3 Swap: Pool 3 > Contract
		//=========================
		STORE_V3_SWAP_SIG()
		STORE_CONTRACT()					// To: Contract

		LOAD_POOL_C_OUT_POS()
		iszero v3_v3_v3_one_for_zero jumpi

		// if 00>01:
		STORE_ZERO_FOR_ONE()
		STORE_THREE_POOL_B_OUT_AMOUNT()
		STORE_MIN_SQRT()
		STORE_OFFSET()
		0xaa
		STORE_DATA_86()
		LOAD_POOL_C()						// Call Swap on this pool
		V3_SWAP()
		stop

		// if 01>00:
		v3_v3_v3_one_for_zero:
			STORE_ONE_FOR_ZERO()
			STORE_THREE_POOL_B_OUT_AMOUNT()
			STORE_MAX_SQRT()
			STORE_OFFSET()
			0xaa
			STORE_DATA_86()
			LOAD_POOL_C()					// Call Swap on this pool
			V3_SWAP()
			stop
	//
	// #8 V3 > V3 > V3 Callback 1
	// V3 Pool 2 swap to Pool 3, trigger callback
	v3_v3_v3_callback_1_jump:
		
		//=========================
		// Check profit
		//=========================
		CALLBACK_LOAD_ACTUAL_AMOUNT_OUT()			// [actual_V3_amount_out+2, actual_V3_amount_in]
		CALLBACK_LOAD_DESIRED_AMOUNT_OUT()			// [desired_amount_out, actual_V3_amount_out+2, actual_V3_amount_in]	
		lt											// [lt?, actual_V3_amount_in]

		v3_v3_v3_callback_continue_1 jumpi
		push0 push0 revert		
		
		v3_v3_v3_callback_continue_1:				// [actual_V3_amount_in]

			//=========================
			// V3 Swap: Pool 2 > Pool 3
			//=========================
			STORE_V3_SWAP_SIG()
			STORE_CALLER()							// To: Pool 3

			CALLBACK_LOAD_POOL_B_OUT_POS()
			iszero v3_v3_v3_callback_1_one_for_zero jumpi

			STORE_ZERO_FOR_ONE()
			CALLBACK_STORE_THREE_POOL_A_OUT_AMOUNT()
			STORE_MIN_SQRT()
			STORE_OFFSET()
			0xaf
			CALLBACK_STORE_DATA_30()
			CALLBACK_LOAD_POOL_B()					// Call Swap on this pool
			V3_SWAP()
			stop

			v3_v3_v3_callback_1_one_for_zero:
				STORE_ONE_FOR_ZERO()
				CALLBACK_STORE_THREE_POOL_A_OUT_AMOUNT()
				STORE_MAX_SQRT()
				STORE_OFFSET()
				0xaf
				CALLBACK_STORE_DATA_30()
				CALLBACK_LOAD_POOL_B()				// Call Swap on this pool
				V3_SWAP()
				stop
	//
	// #8 V3 > V3 > V3 Callback 2
	// V3 Pool 1 swap to Pool 2, trigger callback
	v3_v3_v3_callback_2_jump:

		//=========================
		// V3 Swap: Pool 1 > Pool 2
		//=========================
		STORE_V3_SWAP_SIG()
		STORE_CALLER()							// To: Pool 2

		CALLBACK_LOAD_POOL_A_OUT_POS()
		iszero v3_v3_v3_callback_2_one_for_zero jumpi

		STORE_ZERO_FOR_ONE()
		CALLBACK_STORE_AMOUNT_IN()				// swap_amount
		STORE_MIN_SQRT()
		STORE_OFFSET()
		0xb4
		CALLBACK_STORE_DATA_5()
		CALLBACK_LOAD_POOL_A()					// Call Swap on Pool 1
		V3_SWAP()
		stop

		v3_v3_v3_callback_2_one_for_zero:
			STORE_ONE_FOR_ZERO()
			CALLBACK_STORE_AMOUNT_IN()			// swap_amount
			STORE_MAX_SQRT()
			STORE_OFFSET()
			0xb4
			CALLBACK_STORE_DATA_5()
			CALLBACK_LOAD_POOL_A()				// Call Swap on Pool 1
			V3_SWAP()
			stop

	//
	// #8 V3 > V3 > V3 Callback 3
	// Transfer to Pool 1
	v3_v3_v3_callback_3_jump:

		//=========================
		// Transfer: Contract > Pool 1
		//=========================
		CALLBACK_LOAD_DESIRED_AMOUNT_IN()		// [amount_in, pool_1, actual_v3_amount_in]
		caller									// [pool_1, actual_v3_amount_in]
		address									// [self, amount_in, pool_1, actual_v3_amount_in]

		// Stack needs to be from, to, amount
		TRANSFER_FROM()							// [status, pool_1, actual_v3_amount_in]
		stop

	//
	// #9 V3 > V3 > V2
	// V3 Pool 2 swap to Pool 3, trigger callback
	v3_v3_v2_jump:

		//=========================
		// V3 Swap: Pool 2 > Pool 3
		//=========================
		STORE_V3_SWAP_SIG()
		STORE_POOL_C()					// To: Pool 3

		LOAD_POOL_B_OUT_POS()
		iszero v3_v3_v2_one_for_zero jumpi

		STORE_ZERO_FOR_ONE()
		STORE_THREE_POOL_A_OUT_AMOUNT()
		STORE_MIN_SQRT()
		STORE_OFFSET()
		0xbe
		STORE_DATA_86()
		LOAD_POOL_B()					// Call Swap on this pool
		V3_SWAP()
		stop

		v3_v3_v2_one_for_zero:
			STORE_ONE_FOR_ZERO()
			STORE_THREE_POOL_A_OUT_AMOUNT()
			STORE_MAX_SQRT()
			STORE_OFFSET()
			0xbe
			STORE_DATA_86()
			LOAD_POOL_B()				// Call Swap on this pool
			V3_SWAP()
			stop
	//
	// #9 V3 > V3 > V2 Callback 1
	// V3 Pool 1 swap to Pool 2, trigger callback
	v3_v3_v2_callback_1_jump:
	
		//=========================
		// V3 Swap: Pool 1 > Pool 2
		//=========================
		STORE_V3_SWAP_SIG()
		CALLBACK_STORE_POOL_B()					// To: Pool 2

		CALLBACK_LOAD_POOL_A_OUT_POS()
		iszero v3_v3_v2_callback_1_one_for_zero jumpi

		STORE_ZERO_FOR_ONE()
		CALLBACK_STORE_AMOUNT_IN()				// swap_amount
		STORE_MIN_SQRT()
		STORE_OFFSET()
		0xc3
		CALLBACK_STORE_DATA_86()
		CALLBACK_LOAD_POOL_A()					// Call Swap on Pool 1
		V3_SWAP()
		stop

		v3_v3_v2_callback_1_one_for_zero:
			STORE_ONE_FOR_ZERO()
			CALLBACK_STORE_AMOUNT_IN()			// swap_amount
			STORE_MAX_SQRT()
			STORE_OFFSET()
			0xc3
			CALLBACK_STORE_DATA_86()
			CALLBACK_LOAD_POOL_A()				// Call Swap on Pool 1
			V3_SWAP()
			stop
	//
	// #9 V3 > V3 > V2 Callback 2
	// V2 Pool 3 swap to contract, Transfer to Pool 1
	v3_v3_v2_callback_2_jump:
		
		//=========================
		// V2 Swap: Pool 3 > Contract
		//=========================
		CALLBACK_LOAD_POOL_C()					// [pool_3]
		address									// [self, pool_3]
		CALLBACK_LOAD_DESIRED_AMOUNT_OUT()		// [desired_amount_out, self, pool_3]
		push0									// [0, desired_amount_out, self, pool_3]
		
		// If pool 3 out pos is 0, swap amounts
		CALLBACK_LOAD_POOL_C_OUT_POS()			
		iszero v3_v3_v2_callback_2_one_for_zero jumpi
		
		v3_v3_v2_callback_2_continue jump

		v3_v3_v2_callback_2_one_for_zero:
			swap1								// [pool_2_out, 0, pool_3, pool_2]

		// Stack needs to be amount0, amount1, contract, pool_3
		v3_v3_v2_callback_2_continue:
			V2_SWAP()							// [result]
			
		//=========================
		// Transfer: Contract > Pool 1
		//=========================
		CALLBACK_LOAD_DESIRED_AMOUNT_IN()		// [desired_amount_in]
		CALLBACK_LOAD_POOL_A()					// [pool_1, desired_amount_in]
		address									// [self, pool_1, desired_amount_in]

		// Stack needs to be from, to, amount
		TRANSFER_FROM()							// [status]
		stop
	//
	// #10 V3 > V2 > V3
	// V3 Pool 3 swap to contract, trigger callback
	v3_v2_v3_jump:

		//=========================
		// V3 Swap: Pool 3 > Contract
		//=========================
		STORE_V3_SWAP_SIG()
		STORE_CONTRACT()						// To: Contract

		LOAD_POOL_C_OUT_POS()
		iszero v3_v2_v3_one_for_zero jumpi

		STORE_ZERO_FOR_ONE()
		STORE_THREE_POOL_A_OUT_AMOUNT()
		STORE_MIN_SQRT()
		STORE_OFFSET()
		0xcd
		STORE_DATA_86()
		LOAD_POOL_C()							// Call Swap on Pool 3
		V3_SWAP()
		stop

		v3_v2_v3_one_for_zero:
			STORE_ONE_FOR_ZERO()
			STORE_THREE_POOL_A_OUT_AMOUNT()
			STORE_MAX_SQRT()
			STORE_OFFSET()
			0xcd
			STORE_DATA_86()
			LOAD_POOL_C()						// Call Swap on Pool 3
			V3_SWAP()
			stop
	//
	// #10 V3 > V2 > V3 Callback 1
	// V3 Pool 1 swap to Pool 2, trigger callback
	v3_v2_v3_callback_1_jump:

		//=========================
		// Check profit
		//=========================
		CALLBACK_LOAD_ACTUAL_AMOUNT_OUT()			// [actual_V3_amount_out+2, actual_V3_amount_in]
		CALLBACK_LOAD_DESIRED_AMOUNT_OUT()			// [desired_amount_out, actual_V3_amount_out+2, actual_V3_amount_in]	
		lt											// [lt?, actual_V3_amount_in]

		v3_v2_v3_callback_continue_1 jumpi
		push0 push0 revert		
		
		v3_v2_v3_callback_continue_1:				// [actual_V3_amount_in]

			//=========================
			// V3 Swap: Pool 1 > Pool 2
			//=========================
			STORE_V3_SWAP_SIG()
			CALLBACK_STORE_POOL_B()					// To: Pool 2

			CALLBACK_LOAD_POOL_A_OUT_POS()
			iszero v3_v2_v3_callback_1_one_for_zero jumpi

			STORE_ZERO_FOR_ONE()
			CALLBACK_STORE_AMOUNT_IN()				// swap_amount
			STORE_MIN_SQRT()
			STORE_OFFSET()
			0xd2
			CALLBACK_STORE_DATA_86()
			CALLBACK_LOAD_POOL_A()					// Call Swap on Pool 1
			V3_SWAP()
			stop

			v3_v2_v3_callback_1_one_for_zero:
				STORE_ONE_FOR_ZERO()
				CALLBACK_STORE_AMOUNT_IN()			// swap_amount
				STORE_MAX_SQRT()
				STORE_OFFSET()
				0xd2
				CALLBACK_STORE_DATA_86()
				CALLBACK_LOAD_POOL_A()				// Call Swap on Pool 1
				V3_SWAP()
				stop
	//
	// #10 V3 > V2 > V3 Callback 2
	// Transfer to Pool 1, V2 Pool 2 swap to Pool 3
	v3_v2_v3_callback_2_jump:

		//=========================
		// Transfer: Contract > Pool 1
		//=========================
		CALLBACK_LOAD_DESIRED_AMOUNT_IN()		// [amount_in]
		caller									// [pool_1, actual_v3_amount_in]
		address									// [self, pool_1, amount_in]

		// Stack needs to be from, to, amount
		TRANSFER_FROM()							// [status]


		//=========================
		// V2 Swap: Pool 2 > Pool 3
		//=========================
		CALLBACK_LOAD_POOL_B()					// [pool_2]
		CALLBACK_LOAD_POOL_C()					// [pool_3, pool_2]
		CALLBACK_LOAD_POOL_A_OUT_AMOUNT()		// [pool_2_out, pool_3, pool_2]
		push0									// [0, pool_2_out, pool_3, pool_2]
		
		// If pool 2 out pos is 0, swap amounts
		CALLBACK_LOAD_POOL_B_OUT_POS()			
		iszero v3_v2_v3_callback_2_one_for_zero jumpi
		
		v3_v2_v3_callback_2_continue jump

		v3_v2_v3_callback_2_one_for_zero:
			swap1								// [pool_2_out, 0, pool_3, pool_2]

		// Stack needs to be amount0, amount1, pool_3, pool_2
		v3_v2_v3_callback_2_continue:
			V2_SWAP()							// [result, pool_1]
			stop

	//
	// #11 V3 > V2 > V2
	// V3 Pool 1 swap to Pool 2, trigger callback
	v3_v2_v2_jump:

		//=========================
		// V3 Swap: Pool 1 > Pool 2
		//=========================
		STORE_V3_SWAP_SIG()
		STORE_POOL_B()					// To: V2

		LOAD_POOL_A_OUT_POS()
		iszero v3_v2_v2_one_for_zero jumpi

		STORE_ZERO_FOR_ONE()
		STORE_AMOUNT_IN()
		STORE_MIN_SQRT()
		STORE_OFFSET()
		0xdc
		STORE_DATA_86()
		LOAD_POOL_A()					// Call Swap on this pool
		V3_SWAP()
		stop

		v3_v2_v2_one_for_zero:
			STORE_ONE_FOR_ZERO()
			STORE_AMOUNT_IN()
			STORE_MAX_SQRT()
			STORE_OFFSET()
			0xdc
			STORE_DATA_86()
			LOAD_POOL_A()					// Call Swap on this pool
			V3_SWAP()
			stop
	//
	// #11 V3 > V2 > V2 Callback 1
	// V2 Pool 2 swap to Pool 3, V2 Pool 3 swap to contract, Transfer to Pool 1
	v3_v2_v2_callback_1_jump:

		//=========================
		// V2 Swap: Pool 2 > Pool 3
		//=========================
		CALLBACK_LOAD_POOL_B()					// [pool_2, actual_v3_amount_in]
		CALLBACK_LOAD_POOL_C()					// [pool_3, pool_2, actual_v3_amount_in]
		CALLBACK_LOAD_POOL_A_OUT_AMOUNT()		// [pool_2_out, pool_3, pool_2, actual_v3_amount_in]
		push0									// [0, pool_2_out, pool_3, pool_2, actual_v3_amount_in]
		
		// If pool 2 out pos is 0, swap amounts
		CALLBACK_LOAD_POOL_B_OUT_POS()			
		iszero v3_v2_v2_callback_pool_b_zero_jump jumpi
		
		v3_v2_v2_callback_continue_3 jump

		v3_v2_v2_callback_pool_b_zero_jump:
			swap1								// [pool_2_out, 0, pool_3, pool_2, actual_v3_amount_in]

		// Stack needs to be amount0, amount1, pool_3, pool_2
		v3_v2_v2_callback_continue_3:
			// Stack: pool_2_out, 0, to, from
			V2_SWAP()							// [result, pool_1, actual_v3_amount_in]

		//=========================
		// V2 Swap: Pool 3 > Contract
		//=========================
		CALLBACK_LOAD_POOL_C()					// [pool_3, actual_v3_amount_in]
		address									// [self, pool_3, actual_v3_amount_in]
		CALLBACK_LOAD_DESIRED_AMOUNT_OUT()		// [desired_amount_out, self, pool_3, actual_v3_amount_in]
		push0									// [0, desired_amount_out, self, pool_3, actual_v3_amount_in]

		// If pool 1 out pos is 0, swap amounts
		CALLBACK_LOAD_POOL_C_OUT_POS()
		iszero v3_v2_v2_callback_pool_a_zero_jump jumpi

		v3_v2_v2_callback_continue_2 jump		
			
		v3_v2_v2_callback_pool_a_zero_jump:
			swap1								// [pool_1_out_amount, 0, pool_2_copy, pool_1, pool_2, actual_v3_amount_in]
		
		// Stack needs to be amount0, amount1, pool_2, pool_1
		v3_v2_v2_callback_continue_2:
			// Stack: pool_1_out, 0, to, from
			V2_SWAP()							// [result, pool_1, pool_2, actual_v3_amount_in]

		//=========================
		// Transfer: Contract > Pool 1
		//=========================
		CALLBACK_LOAD_DESIRED_AMOUNT_IN()		// [amount_in, pool_1, actual_v3_amount_in]
		caller									// [pool_1, actual_v3_amount_in]
		address									// [self, amount_in, pool_1, actual_v3_amount_in]

		// Stack needs to be from, to, amount
		TRANSFER_FROM()							// [status, pool_1, actual_v3_amount_in]
		stop
	//
	// Withdraw WETH
	withdraw_weth_jump:
		WITHDRAW_WETH()
	// Withdraw ETH
	withdraw_eth_jump:
		WITHDRAW_ETH()
	// Deposit WETH
	deposit_weth_jump:
		DEPOSIT_WETH()
	// Deposit ETH
	deposit_eth_jump:
		DEPOSIT_ETH()
	// Fallback
	fallback:
		push0 push0 revert
	
}



//==========================
// CALLS
//==========================
#define macro TRANSFER_FROM() = takes(0) returns(0) {
	
	// 23b872dd
	[TRANSFER_FROM_SIG] 							// [TRANSFER_FROM_SIG, from_address, to_address, amount_in]
	push0 
	mstore											// [from_address, to_address, amount_in]
	0x04 
	mstore 											// [to_address, amount_in]
	0x24 
	mstore 											// [amount_in]
	0x44 
	mstore 											// []

	// Set up the CALL parameters
	push0											// [out_size]
	push0											// [out_offset, out_size]
	0x64 // 100										// [in_size, out_offset, out_size]
	push0											// [in_offset, in_size, out_offset, out_size]
	push0											// [value, in_offset, in_size, out_offset, out_size]
	[WETH]											// [WETH, value, in_offset, in_size, out_offset, out_size]

	gas												// [gas, WETH, value, in_offset, in_size, out_offset, out_size]
	call
	CHECK_CALL_STATUS()

}

#define macro TRANSFER() = takes(0) returns(0) {
	
	// a9059cbb
	[TRANSFER_SIG] 									// [TRANSFER_FROM_SIG, to_address, amount_in, flag]
	push0 
	mstore											// [to_address, amount_in, flag]
	0x04 
	mstore 											// [amount_in, flag]
	0x24 
	mstore 											// [amount_in, flag]

	// Set up the CALL parameters
	push0											// [out_size, flag]
	push0											// [out_offset, out_size, flag]
	0x44 // 100										// [in_size, out_offset, out_size, flag]
	push0											// [in_offset, in_size, out_offset, out_size, flag]
	push0											// [value, in_offset, in_size, out_offset, out_size, flag]
	[WETH]											// [WETH, value, in_offset, in_size, out_offset, out_size, flag]

	gas												// [gas, WETH, value, in_offset, in_size, out_offset, out_size, flag]
	call
	CHECK_CALL_STATUS()

}

#define macro V2_SWAP() = takes(0) returns(0) {
	
	// 022c0d9f
	[V2_SWAP_SIG]  									// [V2_SWAP_SIG, amount0Out, amount1Out, recipient, v2_pool]
	push0
	mstore	// V2_SWAP_SIG							// [amount0Out, amount1Out, recipient, v2_pool]
	0x04
	mstore	// amount0Out 							// [amount1Out, recipient, v2_pool]
	0x24
	mstore	// amount1Out							// [recipient, v2_pool]
	0x44
	mstore	// recipient							// [v2_pool]
	0x80											// [80, v2_pool]
	0x64
	mstore	// offset								// [v2_pool]
	push0											// [0, v2_pool]
	0x84
	mstore	// data									// [v2_pool]

	// SET UP CALL PARAMETERS
	push0											// [out_size, v2_pool]
	push0											// [out_offset, out_size, v2_pool]
	0xa4 // 164										// [in_size, out_offset, out_size, v2_pool]
	push0											// [in_offset, in_size, out_offset, out_size, v2_pool]
	push0											// [value, in_offset, in_size, out_offset, out_size, v2_pool]
	
	// LOAD V2 ADDRESS
	dup6											// [v2_pool_copy, value, in_offset, in_size, out_offset, out_size, v2_pool]
	
	gas 											// [gas, v2_pool_copy, value, in_offset, in_size, out_offset, out_size, v2_pool]
	call
	CHECK_CALL_STATUS()

}

#define macro V3_SWAP() = takes(0) returns(0) {
	
	// SET UP CALL PARAMETERS
	push0											// [out_size]
	push0											// [out_offset, out_size]
	dup4											// [in_size, out_offset, out_size]
	push0											// [in_offset, in_size, out_offset, out_size]
	push0											// [value, in_offset, in_size, out_offset, out_size]
	
	// LOAD V3 ADDRESS
	dup6

	// SEND CALL AND STOP
	gas 											// [gas, v3_pool, value, in_offset, in_size, out_offset, out_size]
	call
	CHECK_CALL_STATUS()
}


//==========================
// POOLS
//==========================
#define macro LOAD_POOL_A() = takes(0) returns (0) {
	0x09											// [9 (9), amount_in, flag]
	calldataload									// [calldata, amount_in, flag]
	0x60 											// [60 (96 > 12), calldata, amount_in, flag]
	shr												// [v2_pool, amount_in, flag]
}

#define macro LOAD_POOL_B() = takes(0) returns (0) {
	0x1e											// [1e (30), amount_in, flag]
	calldataload									// [calldata, amount_in, flag]
	0x60 											// [60 (96 > 12), calldata, amount_in, flag]
	shr												// [v2_pool, amount_in, flag]
}

#define macro LOAD_POOL_C() = takes(0) returns (0) {
	0x33											// [33 (51), amount_in, flag]
	calldataload									// [calldata, amount_in, flag]
	0x60 											// [60 (96 > 12), calldata, amount_in, flag]
	shr												// [v2_pool, amount_in, flag]
}

#define macro CALLBACK_LOAD_POOL_A() = takes(0) returns (0) {
	0x8d											// [8d (141), amount_in, flag]
	calldataload									// [calldata, amount_in, flag]
	0x60 											// [60 (96 > 12), calldata, amount_in, flag]
	shr												// [v2_pool, amount_in, flag]
}

#define macro CALLBACK_LOAD_POOL_B() = takes(0) returns (0) {
	0xa2											// [a2 (162), amount_in, flag]
	calldataload									// [calldata, amount_in, flag]
	0x60 											// [60 (96 > 12), calldata, amount_in, flag]
	shr												// [v2_pool, amount_in, flag]
}

#define macro CALLBACK_LOAD_POOL_C() = takes(0) returns (0) {
	0xb7											// [b7 (183), amount_in, flag]
	calldataload									// [calldata, amount_in, flag]
	0x60 											// [60 (96 > 12), calldata, amount_in, flag]
	shr												// [v2_pool, amount_in, flag]
}

#define macro STORE_POOL_A() = takes(0) returns(0) {
	0x14 // length to copy
	0x09 // point in calldata to start from
	0x10 // memory location to paste, 4 position + 12 bytes to right align 20 bytes
	calldatacopy
}

#define macro STORE_POOL_B() = takes(0) returns(0) {
	0x14 // length to copy
	0x1e // point in calldata to start from
	0x10 // memory location to paste, 4 position + 12 bytes to right align 20 bytes
	calldatacopy
}

#define macro STORE_POOL_C() = takes(0) returns(0) {
	0x14 // length to copy
	0x33 // point in calldata to start from
	0x10 // memory location to paste, 4 position + 12 bytes to right align 20 bytes
	calldatacopy
}

#define macro CALLBACK_STORE_POOL_A() = takes(0) returns(0) {
	0x14 // length to copy
	0x8d // point in calldata to start from
	0x10 // memory location to paste, 4 position + 12 bytes to right align 20 bytes
	calldatacopy
}

#define macro CALLBACK_STORE_POOL_B() = takes(0) returns(0) {
	0x14 // length to copy
	0xa2 // point in calldata to start from
	0x10 // memory location to paste, 4 position + 12 bytes to right align 20 bytes
	calldatacopy
}

#define macro CALLBACK_STORE_POOL_C() = takes(0) returns(0) {
	0x14 // length to copy
	0xb7 // point in calldata to start from
	0x10 // memory location to paste, 4 position + 12 bytes to right align 20 bytes
	calldatacopy
}


//==========================
// OUPUT POSITIONS
//==========================
#define macro LOAD_POOL_A_OUT_POS() = takes(0) returns(0) {
	0x1d					// [1d (29)]
	calldataload			// [calldata]			
	push0					// [0, calldata]								
	byte					// [out_pos_a]
}

#define macro LOAD_POOL_B_OUT_POS() = takes(0) returns(0) {
	0x32					// [32, 50)]
	calldataload			// [calldata]			
	push0					// [0, calldata]								
	byte					// [out_pos_b]
}

#define macro LOAD_POOL_C_OUT_POS() = takes(0) returns(0) {
	0x47					// [47 (71)]
	calldataload			// [calldata]			
	push0					// [0, calldata]								
	byte					// [out_pos_c]
}

#define macro CALLBACK_LOAD_POOL_A_OUT_POS() = takes(0) returns(0) {
	0xa1					// [a1 (161)]
	calldataload			// [calldata]			
	push0					// [0, calldata]								
	byte					// [out_pos_a]
}

#define macro CALLBACK_LOAD_POOL_B_OUT_POS() = takes(0) returns(0) {
	0xb6					// [b6 (182)]
	calldataload			// [calldata]			
	push0					// [0, calldata]								
	byte					// [out_pos_a]
}

#define macro CALLBACK_LOAD_POOL_C_OUT_POS() = takes(0) returns(0) {
	0xcb					// [cb (203)]
	calldataload			// [calldata]			
	push0					// [0, calldata]								
	byte					// [out_pos_c]
}


//==========================
// INTERIOR OUTPUT AMOUNTS
//==========================
#define macro STORE_TWO_POOL_A_OUT_AMOUNT() = takes(0) returns(0) {
	0x0e // length to copy
	0x33 // point in calldata to start from
	0x56 // memory location to paste, 44 position + 18 bytes to right align 14 bytes
	calldatacopy

	// 0x33											// [33 (51)]
	// calldataload									// [calldata]
	// 0x90											// [90 (144 > 18), calldata]
	// shr												// [v2_pool_1_out]
	// 0x44 											// [44, v2_pool_1_out]
	// mstore					 						// []
}

#define macro STORE_THREE_POOL_A_OUT_AMOUNT() = takes(0) returns(0) {
	0x0e // length to copy
	0x48 // point in calldata to start from
	0x56 // memory location to paste, 44 position + 18 bytes to right align 14 bytes
	calldatacopy

	// 0x48											// [48 (72)]
	// calldataload									// [calldata]
	// 0x90											// [90 (144 > 18), calldata]
	// shr												// [v2_pool_1_out]
	// 0x44 											// [44, v2_pool_1_out]
	// mstore					 						// []
}

#define macro STORE_THREE_POOL_B_OUT_AMOUNT() = takes(0) returns(0) {
	0x0e // length to copy
	0x56 // point in calldata to start from
	0x56 // memory location to paste, 44 position + 18 bytes to right align 14 bytes
	calldatacopy

	// 0x56											// [56 (86)]
	// calldataload									// [calldata]
	// 0x90											// [90 (144 > 18), calldata]
	// shr												// [v2_pool_1_out]
	// 0x44 											// [44, v2_pool_1_out]
	// mstore					 						// []
}

#define macro CALLBACK_LOAD_POOL_A_OUT_AMOUNT() = takes(0) returns(0) {
	0xcc											// [cc (204)]
	calldataload									// [calldata]
	0x90											// [90 (144 > 18), calldata]
	shr												// [pool_a_out_amount]
}

#define macro CALLBACK_LOAD_POOL_B_OUT_AMOUNT() = takes(0) returns(0) {
	0xda											// [da (218)]
	calldataload									// [calldata]
	0x90											// [90 (144 > 18), calldata]
	shr												// [pool_b_out_amount]
}

#define macro CALLBACK_STORE_THREE_POOL_A_OUT_AMOUNT() = takes(0) returns(0) {
	0x0e // length to copy
	0xcc // point in calldata to start from
	0x56 // memory location to paste, 44 position + 18 bytes to right align 14 bytes
	calldatacopy
}

#define macro CALLBACK_STORE_THREE_POOL_B_OUT_AMOUNT() = takes(0) returns(0) {
	0x0e // length to copy
	0xda // point in calldata to start from
	0x56 // memory location to paste, 44 position + 18 bytes to right align 14 bytes
	calldatacopy
}


//==========================
// AMOUNTS
//==========================
#define macro STORE_AMOUNT_IN() = takes(0) returns(0) {
	0x04 // length to copy
	0x01 // point in calldata to start from
	0x5b // memory location to paste, 0x44 (68) position + 23 bytes to right align 4 bytes with 5 bytes of zeros
	calldatacopy
}

#define macro STORE_AMOUNT_OUT() = takes(0) returns (0) {
	0x04 // length to copy
	0x05 // point in calldata to start from
	0x5b // memory location to paste, 0x44 (68) position + 23 bytes to right align 4 bytes with 5 bytes of zeros
	calldatacopy
}

#define macro CALLBACK_STORE_AMOUNT_IN() = takes(0) returns(0) {
	0x04 // length to copy
	0x85 // point in calldata to start from
	0x5b // memory location to paste, 0x44 (68) position + 23 bytes to right align 4 bytes with 5 bytes of zeros
	calldatacopy
}

#define macro CALLBACK_STORE_AMOUNT_OUT() = takes(0) returns(0) {
	0x04 // length to copy
	0x8a // point in calldata to start from
	0x5b // memory location to paste, 0x44 (68) position + 23 bytes to right align 4 bytes with 5 bytes of zeros
	calldatacopy								
}


//==========================
// CALLBACK AMOUNTS
//==========================
#define macro CALLBACK_LOAD_DESIRED_AMOUNT_IN() = takes(0) returns(0) {
	0x85											// [85 (133), flag]
	calldataload									// [calldata, flag]
	0xe0 											// [e0 (224 > 28), calldata]
	shr												// [amount_in, flag]
	0x28 											// [28 (40 > 5), amount_in, flag]
	shl												// [amount_in, flag]
}

#define macro CALLBACK_LOAD_DESIRED_AMOUNT_OUT() = takes(0) returns(0) {
	0x89											// [89 (137), flag]
	calldataload									// [calldata, flag]
	0xe0 											// [e0 (224 > 28), calldata]
	shr												// [amount_out, flag]
	0x28 											// [28 (40 > 5), amount_out, flag]
	shl												// [amount_out, flag]
}

#define macro CALLBACK_SWAP_AMOUNT_0_IN() = takes(0) returns (0) {
	0x04
	calldataload								// [amount1Delta (v3_amount_in), amount_out, flag]
}

#define macro CALLBACK_SWAP_AMOUNT_1_IN() = takes(0) returns (0) {
	0x24
	calldataload								// [amount1Delta (v3_amount_in), amount_out, flag]
}

#define macro CALLBACK_SWAP_AMOUNT_0_OUT() = takes(0) returns (0) {
	0x04 										// [24, amount_out, flag]	
	calldataload								// [amount0Delta (v3_amount_out), amount_out, flag]
	not											// [amount0Delta (v3_amount_out), amount_out, flag]
	0x02										// [2, amount0Delta (v3_amount_out), amount_out, flag]
	add											// [amount0Delta (v3_amount_out), amount_out, flag]
}

#define macro CALLBACK_SWAP_AMOUNT_1_OUT() = takes(0) returns (0) {
	0x24 										// [24, amount_out, flag]	
	calldataload								// [amount0Delta (v3_amount_out), amount_out, flag]
	not											// [amount0Delta (v3_amount_out), amount_out, flag]
	0x02										// [2, amount0Delta (v3_amount_out), amount_out, flag]
	add											// [amount0Delta (v3_amount_out), amount_out, flag]
}

#define macro CALLBACK_LOAD_ACTUAL_AMOUNT_OUT() = takes(0) returns(0) {
	0x04					// [04]
	calldataload			// [token_0_amount]
	0x24					// [24, token_0_amount]
	calldataload			// [token_1_amount, token_0_amount]
	dup2					// [token_0_amount_copy, token_1_amount, token_0_amount]]
	dup2					// [token_1_amount_copy, token_0_amount_copy, token_1_amount, token_0_amount]
	slt						// [token_1_lt_token_0?, token_1_amount, token_0_amount]
	
	// token 1 is less than token 0, so it's a token 1 out
	token_one_out_jump jumpi

	// token 0 is less than token 1, so it's a token 0 out
	swap1					// [token_0_amount, token_1_amount]
	not						// [token_0_amount_positive, token_1_amount]
	0x02					// [02, token_0_amount_positive, token_1_amount]
	add						// [token_0_amount_positive + 2, token_1_amount]
	
	callback_load_actual_amount_out_continue jump

	token_one_out_jump:
		not					// [token_1_amount, token_0_amount]
		0x02				// [02, token_1_amount_positive, token_0_amount]
		add					// [token_1_amount_positive + 2, token_0_amount]

	callback_load_actual_amount_out_continue:
}


//==========================
// CONSTANTS
//==========================
#define macro STORE_V3_SWAP_SIG() = takes (0) returns(0) {
	[V3_SWAP_SIG]									// [V3_SWAP_SIG]
	push0 											// [0, V3_SWAP_SIG]
	mstore											// []
}

#define macro STORE_CONTRACT() = takes(0) returns(0) {
	address											// [address(this)]
	0x04 											// [4, address(this)]
	mstore					 						// []
}

#define macro STORE_CALLER() = takes(0) returns(0) {
	caller											// [address(this)]
	0x04 											// [4, address(this)]
	mstore					 						// []
}

#define macro STORE_ZERO_FOR_ONE() = takes(0) returns(0) {
	0x01											// [1]
	0x24											// [24, 1]
	mstore 											// []
}

#define macro STORE_ONE_FOR_ZERO() = takes(0) returns(0) {
	push0											// [1]
	0x24											// [24, 1]
	mstore 											// []
}

#define macro STORE_MIN_SQRT() = takes(0) returns(0) {
	[MIN_SQRT_RATIO]								// [MIN_SQRT_RATIO]
	0x64											// [64, MIN_SQRT_RATIO]
	mstore											// []
}

#define macro STORE_MAX_SQRT() = takes(0) returns(0) {
	[MAX_SQRT_RATIO]								// [MAX_SQRT_RATIO]
	0x64											// [64, MAX_SQRT_RATIO]
	mstore											// []
}

#define macro STORE_OFFSET() = takes(0) returns(0) {
	0xa0											// [a0]
	0x84											// [84, a0] 
	mstore											// []
}


//==========================
// DATA
//==========================
#define macro STORE_DATA_100() = takes(1) returns(0) {
	0x64 // length to copy
	push0 // point in calldata to start from
	0xc4 // memory location to paste
	calldatacopy
	0xa5											// [a5, input]
	mstore											// []
	0x64											// [64 (100)]
	0xa4											// [a4, 64]
	mstore											// []
	0x128											// [128 (296)] (Total length of raw call
}

#define macro STORE_DATA_86() = takes(1) returns(0) {
	0x56 // length to copy
	push0 // point in calldata to start from
	0xc4 // memory location to paste
	calldatacopy
	0xa5											// [a5, input]
	mstore											// []
	0x56											// [56 (86)] Length of bytes data
	0xa4											// [a4, 56]
	mstore											// []
	0x11a											// [11a (282)] (Total length of raw call
}

#define macro STORE_DATA_30() = takes(1) returns(0) {
	0x1e // length to copy
	push0 // point in calldata to start from
	0xc4 // memory location to paste
	calldatacopy
	0xa5											// [a5, input]
	mstore											// []
	0x1e											// [1e (30)] Length of bytes data
	0xa4											// [a4, 1e]
	mstore											// []
	0xe2											// [e2 (226)] Total length of raw call
}

#define macro CALLBACK_STORE_DATA_100() = takes(1) returns(0) {
	0x64 // length to copy
	0x84 // point in calldata to start from
	0xc4 // memory location to paste
	calldatacopy
	0xa5											// [a5, input]
	mstore											// []
	0x64											// [64 (100)]
	0xa4											// [a4, 64]
	mstore											// []
	0x128											// [128 (296)] Total length of raw call
}

#define macro CALLBACK_STORE_DATA_86() = takes(1) returns(0) {
	0x56 // length to copy
	0x84 // point in calldata to start from
	0xc4 // memory location to paste
	calldatacopy
	0xa5											// [a5, input]
	mstore											// []
	0x56											// [56 (86)]
	0xa4											// [a4, 56]
	mstore											// []
	0x11a											// [128 (296)] Total length of raw call
}

#define macro CALLBACK_STORE_DATA_30() = takes(1) returns(0) {
	0x1e // length to copy
	0x84 // point in calldata to start from
	0xc4 // memory location to paste
	calldatacopy
	0xa5											// [a5, flag]
	mstore											// []
	0x1e											// [1e (30)]
	0xa4											// [a4, 1e]
	mstore											// []
	0xe2											// [e2 (226)] Total length of raw call
}

#define macro CALLBACK_STORE_DATA_5() = takes(1) returns(0) {
	0x05 // length to copy
	0x84 // point in calldata to start from
	0xc4 // memory location to paste
	calldatacopy
	0xa5											// [a5, flag]
	mstore											// []
	0x05											// [05 (5)]
	0xa4											// [a4, 05]
	mstore											// []
	0xe4											// Total length of raw call
}


//==========================
// FUNCTIONS
//==========================
#define macro WITHDRAW_WETH() = takes(0) returns (0) {
	// withdrawWETH52() 0x1983e529
	
	0x04
	calldataload
	address

    [TRANSFER_FROM_SIG] push0 mstore				// store 0xa9059cbb as mem(0x00)
	0x04 mstore
    [OWNER] 0x24 mstore								// store OWNER at mem(0x04)
    0x44 mstore										// store amountOut at mem(0x24)

    // make transfer call
    push0											// [retsize]
    push0											// [retoffset, retsize]
    0x64  // 68 (4 + 32 + 32 + 32)						// [argsize, retoffset, retsize]
    push0											// [argoffset, argsize, retoffset, retsize]
    push0											// [value, argoffset, argsize, retoffset, retsize]
    [WETH]											// [weth_addr, value, argoffset, argsize, retoffset, retsize]
    gas												// [gas, weth_addr, value, argoffset, argsize, retoffset, retsize]
    call

	stop

}

#define macro WITHDRAW_ETH() = takes(0) returns (0) {
	// withdrawETH292() 0x1e07a35f

	push0											// [retsize]
    push0											// [retoffset, retsize]
    push0											// [argsize, retoffset, retsize]
    push0											// [argoffset, argsize, retoffset, retsize]
    selfbalance										// [contract_value, argoffset, argsize, retoffset, retsize]
    [OWNER]											// [OWNER, contract_value, argoffset, argsize, retoffset, retsize]
    gas												// [gas, caller, contract_value, argoffset, argsize, retoffset, retsize]
    call											// []

	stop

}

#define macro DEPOSIT_WETH() = takes (0) returns (0) {
	// depositWETH7() 0x236b43c4

	push0
    callvalue
    gt

    deposit jumpi

    deposit:
        [WETH_DEPOSIT_SIG]                              // [WETH_DEPOSIT_SIG, ]
        push0 mstore                                    // []

        // Set up the CALL parameters
        push0                                           // [out_size]
        push0                                           // [out_offset, out_size]
        push0                                       	// [in_size, out_offset, out_size]
        push0                                           // [in_offset, in_size, out_offset, out_size]
        callvalue                                       // [value, in_offset, in_size, out_offset, out_size]
        
        [WETH]                                          // [WETH, value, in_offset, in_size, out_offset, out_size, calldata, v3_amount_out, v3_amount_in]
        gas
        call

	stop

}

#define macro DEPOSIT_ETH() = takes(0) returns (0) {
	// depositETH206() 0x284cf349
	
	callvalue iszero error jumpi 					// revert if msg.value == 0
	stop
    error:
        push0 push0 revert

}

#define macro CHECK_CALL_STATUS() = takes (0) returns (0) {
    success jumpi									// If the call was successful (status == 1), jump to success
    push0 push0 revert								// If the call failed (status == 0), revert the transaction
    success:
}